<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    @font-face {
      font-family: 'pxFont';
      src: url(./VonwaonBitmap-16pxLite.ttf);
    }

    * {
      padding: 0;
      margin: 0;
      font-family: 'pxFont';
    }

    body {
      background-color: #98FB98;
    }

    header {
      text-align: center;
      font-size: 60px;
      /* font-weight: ; */

      margin-top: 10px;
      /* margin-bottom: 20px; */
    }

    HR {
      margin: 0 auto;
      margin-top: 2px;

    }

    .pBox {
      margin-top: 20px;
      margin-left: 40px;
      font-size: 28px;
      margin-bottom: 18px;
    }

    #regInput {
      width: 90%;
      height: 50px;
      display: block;
      margin: 40px auto;
      font-size: 28px;
      outline: 0;
      border: 1px solid black;
      padding-left: 15px;
      background-color: transparent;
      box-sizing: border-box;
    }

    #regInput:focus {
      border: 3px solid black;
    }

    .pBox p:nth-child(1) {
      font-weight: 900;
      font-size: 30px;
    }

    .pBox p:nth-child(5) {
      color: rgb(179, 64, 65);
    }

    .pBox p:nth-child(6) {

      color: rgb(179, 64, 65);
    }


    button {
      width: 200px;
      height: 40px;
      display: block;
      margin: 60px auto;
      margin-top: 20px;
      margin-bottom: 20px;
      font-size: 24px;
      font-weight: 900;
      border: 2px solid black;
      background-color: transparent;
      color: black;
      text-align: center;
      line-height: 38px;
      cursor: pointer;
      transition: .2s;


    }

    button:hover {
      color: white;
      background-color: black;

    }

    .explain {
      display: inline-block;
      margin-top: 20px;
      margin-left: 40px;
      font-size: 28px;
    }

    .err {

      font-size: 28px;
      color: rgb(179, 64, 65);
      display: none;
    }

    .mask {
      width: 100%;
      min-height: 100vh;
      background-color: rgba(0, 0, 0, .9);
      position: absolute;
      left: 0;
      top: 0;
      overflow-x: hidden;
      overflow-y: auto;
    }

    .close {
      font-family: 'FangSong';
      width: 40px;
      height: 40px;
      border-radius: 900000px;
      border: 3px solid black;
      background-color: grey;
      color: white;
      position: fixed;
      left: 20px;
      top: 25px;
      text-align: center;
      line-height: 40px;
      font-weight: 900;
      cursor: pointer;
      transition: .2s;
    }

    .close:hover {
      background-color: white;
      color: black;

    }

    .svgBox {
      height: auto;
      margin: 100px auto;
      /* background-color: rgb(212, 206, 194); */
      overflow-x: auto;
      overflow-y: hidden;
      border-radius: 5px;

    }

    footer {
      width: 500px;
      height: auto;
      display: block;
      margin: 10px auto;
      font-size: 20px;
      text-align: center;
    }

    .name {
      text-decoration: none;
      color: white;
      cursor: pointer;
    }

    .name:hover {
      color: blue
    }

    .download {
      text-decoration: none;
      color: black;
      cursor: pointer;
      position: fixed;
      font-size: 23px;
      right: 30px;
      top: 30px;
      color: white;
      background-color: grey;
      display: block;
      padding: 5px;
    }

    .download:hover {
      background-color: white;
      color: black;
      transition: .2s;
    }
  </style>
</head>

<body>
  <header>正则解析图</header>
  <HR style="FILTER: alpha(opacity=100,finishopacity=0,style=2)" width="98%" color="black" SIZE=4>
  <HR style="FILTER: alpha(opacity=100,finishopacity=0,style=2)" width="98%" color="black" SIZE=4>

  <div class="pBox">
    <p>【简介】</p>
    <p>这是一个可以将您需要的正则表达式解析成可视化路线图的网站</p>
    <br>
    <p>请使用正确规范的正则表达式输入</p>
    <p>1.量词符{}里面不可有空格</p>
    <p>2.无法解析转义字符</p>
    <p>3.零宽断言不计算在捕获分组计数之内</p>
    <p>4.不显示量词符具体循环了几次</p>
    <p>5.字符集取反则字符集背景是红色</p>
    <p>6.不区分贪婪匹配</p>
  </div>
  <HR style="FILTER: alpha(opacity=100,finishopacity=0,style=2)" width="98%" color="black" SIZE=4>
  <HR style="FILTER: alpha(opacity=100,finishopacity=0,style=2)" width="98%" color="black" SIZE=4>
  <p class="explain">请在下方输入您想要解析的正则表达式:</p>
  <p class="err">请输入正确的正则表达式！</p>
  <!-- (?:[^aeiwu]*)*([odc]+) -->

  <!-- (a(a(a)?)+)*(p|(?<testname>ccc|ddd|eee|fff))(?!foo)((?<=hufa)|((a{2,4}b{0,99}c{1,99}d{3}e{4}f{4,})*)*(?:[^aeiwu]*)*(cd|ef|(fo[odc]+)+dd)+c[def]|def|abc) -->
  <input type="text" id="regInput"
    value="(a(a(a)?)+)*(p|(?<具名分组aaa>ccc|ddd|eee|fff))(?!foo)((?<=hufa)|((a{2,4}b{0,99}c{1,99}d{3}e{4}f{4,})*)*(?:[^aeiwu]*)*(cd|ef|(fo[odc]+)+dd)+c[def]|def|abc)">
  <button>生成解析图</button>

  <footer>Create By <a href="#" class="name">lips</a> 1548415859@qq.com </footer>


  <script>
    var btn = document.querySelector('button')
    var regInput = document.querySelector('#regInput')

    btn.addEventListener('click', function (e) {

      var errBox = document.querySelector('.err')
      errBox.textContent = ""
      errBox.style.display = 'none'
      var maskDiv = document.createElement('div')
      maskDiv.classList.add('mask')
      maskDiv.id = 'maskBox'
      var closeBtn = document.createElement('div')
      closeBtn.classList.add('close')
      closeBtn.textContent = '╳'

      closeBtn.addEventListener('click', function () {
        document.body.removeChild(maskDiv)
      })
      maskDiv.append(closeBtn)
      var svgBox = document.createElement('div')
      svgBox.classList.add('svgBox')
      svgBox.style.width = '80%'
      var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg')
      svg.style.verticalAlign = 'top'
      svg.id = 'svg'
      svg.setAttribute('xmlns', "http://www.w3.org/2000/svg")

      svg.style.minWidth = window.innerWidth * 0.8
      var style = document.createElementNS('http://www.w3.org/2000/svg', 'style')
      style.textContent = `.colorTxt{fill:#B34041;font-weight:600;}`
      svg.append(style)
      svgBox.append(svg)
      maskDiv.append(svgBox)
      var regVal = regInput.value
      try {
        var node = parsePattern(regVal)
      } catch (e) {
        errBox.textContent = e.toString()
        errBox.style.display = 'inline-block'
        return
      }
      var a = document.createElement('a')
      var fileLoad = document.createElement('input')
      fileLoad.setAttribute('type', 'file')
      fileLoad.setAttribute('id', 'fileInput')
      fileLoad.setAttribute('hidden', true)
      fileLoad.setAttribute('accept', "*.svg")
      maskDiv.append(fileLoad)
      a.textContent = '下载 SVG'
      a.classList.add('download')
      a.addEventListener('click', function () {
        var svgSource = svg.outerHTML
        var blob = new Blob(['<?xml version="1.0" encoding="UTF-8"?>', svgSource], { type: 'image/xml+svg' })
        var url = URL.createObjectURL(blob)
        var anchor = document.createElement('a')
        anchor.href = url
        anchor.download = 'Regexper.svg'
        anchor.click()
      })
      maskDiv.append(a)


      document.body.append(maskDiv)
      createPatternGraph(node)



    })



    //解析单个字符的函数 parseCharacter
    //解析字符集的函数  parseCharacterClass [^abc]
    //解析量词符的函数   parseQuantifier    parseNumber用来解析量词符里的数字
    //解析捕获分组的函数  parseCaptrueGroup   parseSimpleString用来解析  剧名分组里的分组名称
    //解析单分支的函数  parseAlternative
    //解析多分支的函数   parseAlternatives
    //parseElement函数用于判断遇到str[i]判断需要使用什么函数解析


    //注意的点：
    //多分支包含单分支  单分支包含分组   分组内又包含多分支
    //即   parseAlternatives会调用parseAlternative
    //     parseAlternative在调用parseElement时可能会解析到str[i]是"("调用parseCaptrueGroup
    //     parseCaptrueGroup里即多分支所以它要调用parseAlternatives
    //groupIndex 用来计算分组计数的  计算某个括号分组是第几个分组   注意断言是不算在分组计数内的
    //但是具名分组会算在分组计数内
    //量词符{1,2}  {3,} {4}  最后一个表示最大出现次数和最小出现次数只能都是4
    //解析到量词符号的时候str单纯只能解析出是什么量词符  但是解析不出该量词符代表那个部分的重复
    //所以它在单分支结构中被拿到数组里的时候会和它前一个部分组成一整个完整的量词符重复部分再push进单分支数组里去



    //=============================================语法树解析部分==========================================
    //    raw     代表从解析开始到解析结束的内容 

    //入口函数   得到整个正则表达式解析树
    function parsePattern(input) {
      str = input
      i = 0
      groupIndex = 1
      return {
        type: 'Pattern',
        alternatives: parseAlternatives(),
        raw: input
      }
    }

    //解析出单个完整的部分，可以是字符 字符集  括号 量词
    function parseElement() {
      if (str[i] == '[') {
        return parseCharacterClass()
      }
      if (str[i] == '(') {
        return parseCaptrueGroup()
      }
      if (str[i] == '\\') {       //解析出转义符
        return parseEscape()
      }
      if (str[i] == '?' || str[i] == '*' || str[i] == '+' || str[i] == '{') {
        return parseQuantifier()
      }
      return parseCharacter()
    }


    function parseCharacter() {
      var node = {
        type: 'Character',
        start: i,
        end: 0,
        raw: '',
        value: str[i],
        ascii: str.charCodeAt(i)
      }
      i++
      node.end = i
      node.raw = str.slice(node.start, node.end)
      return node
    }


    function parseCharacterClass() {
      var node = {
        type: 'CharacterClass',
        start: i,
        end: 0,
        raw: '',
        elements: [],
        revert: false     //[^abc]   用于判断字符集是否取反
      }
      i++   //跳过[
      if (str[i] == '^') {
        node.revert = true
        i++  //跳过^
      }
      while (str[i] != ']') {
        var charNode = parseCharacter()
        node.elements.push(charNode)
      }
      i++//跳过]
      node.end = i
      node.raw = str.slice(node.start, node.end)
      return node
    }

    //解析量词符号
    function parseQuantifier() {
      var node = {
        type: 'Quantifier',
        start: i,
        end: 0,
        raw: '',
        element: null,
        greedy: true,  //是否是贪婪匹配
        min: 0,
        max: Infinity,
      }

      if (str[i] == "*") {
        i++   //skip  *     因为*本来就是指该字符可以出现0次或者无数次
      }
      else if (str[i] == "?") {
        node.max = 1
        i++   //skip  ?
      }
      else if (str[i] == "+") {
        node.min = 1
        i++   //skip  +
      }
      else if (str[i] == "{") {    //{222,111}   {111,}  {4}
        i++;//跳过{
        var num = parseNumber()
        node.min = num
        if (str[i] == "}") {
          node.max = num
          i++
        } else {
          i++  //skip ,
          if (str[i] == '}') {
            i++ //skip }
          }
          else {
            var max = parseNumber()
            node.max = max
            i++ //skip }
          }
        }
      }

      if (str[i] == '?') {     //遇到量词符后遇到？ 表示遇到贪婪匹配
        node.greedy = false
        i++  //skip  ?
      }

      node.end = i
      node.raw = str.slice(node.start, node.end)
      return node
    }

    function parseNumber() {     //用来解析量词{ 4 }{ 4, }{ 4}{ 4,}  里的数字的函数
      numStr = ''
      while (str[i] >= '0' && str[i] <= '9') {    //判断条件是该字符是否为数字
        numStr += str[i]
        i++
      }
      return Number(numStr)
    }

    //解析出来单分支     /abc[1234]|(abc)x*d/      abc[1234]就是它要解析出来的东西
    function parseAlternative() {

      var node = {
        type: 'Alternative',
        start: i,
        end: 0,
        raw: '',
        elements: [],
      }


      while (str[i] != '|' && str[i] != ')' && i < str.length) {
        var element = parseElement()
        if (element.type == 'Quantifier') {//如果解析出来的是量词
          var quantifierElement = element
          var preElement = node.elements.pop()

          if (preElement.type == 'Quantifier') {
            throw new SyntaxError('Unexcepted quantifier')
          }

          quantifierElement.element = preElement
          quantifierElement.start = preElement.start
          quantifierElement.raw = str.slice(quantifierElement.start, quantifierElement.end)
          node.elements.push(quantifierElement)
        } else {
          node.elements.push(element)
        }
      }

      //这里不i++   因为碰到下一个str[i] 是|或者)或者大于str.length三个条件用于在多分支里做循环结束条件

      node.end = i  //在while里运行的parseElement()分配到各自的解析函数已经更新了i
      node.raw = str.slice(node.start, node.end)
      return node


    }

    //多分支parseAlternatives直接返回的是一个数组不是一个对象
    //解析出整个多分支   /abc[1234]|(abc)x*d|abc/     abc[1234]|(abc)x*d|abc整个就是它要解析出来的东西
    // 注意  abc|(abc|def) 括号里面的abc|def也是个多分支也是个alternatives 里面包括两个单分支Alternative
    function parseAlternatives() {
      var alternatives = []
      do {
        try {
          var alt = parseAlternative() //每次解析出来一个单分支
        } catch (e) {
          throw e
          return
        }
        alternatives.push(alt) //push进alternatives数组里
        if (str[i] == '|') { //如果下一个碰到的是 |  跳过这个|  继续下一轮单分支解析
          i++
        }
        else if (str[i] == ")") { //如果碰到)或者i已经大于str的length 则结束单分支的解析表示这一层的多分支结束
          break
        } else if (i >= str.length) {
          break
        }
      } while (true)
      return alternatives
    }

    //解析捕获分组
    function parseCaptrueGroup() {
      var node = {
        type: 'CaptrueGroup',
        start: i,
        end: 0,
        raw: '',
        alternatives: null,
        assertion: false, //是否为零宽断言
        lookahead: null,  //判断往哪边看   true向右看  false向左看   是零宽断言才生效 
        positive: null, // 是零宽断言才生效  true  表示某个存在断言内容的匹配 (?=foo)(?<=foo)   false表示某个不存在断言内容的匹配  (?!foo)(?<!foo)
        index: groupIndex++,//分组计数是第几个分组   这样写每调用一次parseCaptrueGroup就又解析出来了一个()分组 index自动++
        name: null    //用来接收具名分组的名称  不是具名分组此属性无用
      }
      i++  //skip (
      //先判断是不是断言  是断言判断完是什么断言再解析里面的多分支 
      //不是断言直接解析里面的多分支   注意断言不算在分组计数内  具名分组会算在分组计数内
      if (str[i] == '?') {
        i++    //skip ?
        if (str[i] == ":") {  //只是非捕获分组不是零宽断言
          node.index = 0;
          groupIndex--;
          i++;
          node.name = 'No Captrue'
        }
        else if (str[i] == '=') {  //(?=)
          node.index = 0;
          groupIndex--;
          node.assertion = true
          node.lookahead = true
          node.positive = true
          i++
          node.name = 'lookahead'
        }
        else if (str[i] == '!') {  //(?!) 
          node.index = 0
          groupIndex--
          node.assertion = true
          node.lookahead = true
          node.positive = false
          i++
          node.name = 'Neg lookahead'
        }
        else if (str[i] == '<') {
          i++   //跳过 <
          if (str[i] == '=') {   //(?<=) 
            node.index = 0
            groupIndex--
            node.assertion = true
            node.lookahead = false
            node.positive = true
            i++
            node.name = 'lookbehind'
          }
          else if (str[i] == '!') {  //(?<!) 
            node.index = 0
            groupIndex--
            node.assertion = true
            node.lookahead = false
            node.positive = false
            i++
            node.name = 'Neg lookbehind'
          }
          else {       //(?<name>aaa)  具名分组 
            var name = parseSimpleString()
            node.name = name
            i++   //skip > 
          }
        }

      }
      node.alternatives = parseAlternatives()  //不是断言    则直接解析里面的分支结构
      i++  //skip ）

      node.end = i
      node.raw = str.slice(node.start, node.end)
      return node

    }
    function parseSimpleString() {   //单纯是配合parseCaptrueGroup解析具名分组里名字的函数没有什么难点
      var simStr = ''
      while (str[i] != '>') {
        simStr += str[i++]
      }
      return simStr.trim()  //细节处理一下两边空格
    }


    var padding = 10

    //=============================================画图部分==========================================

    //用来返回画完图的函数createPatternGraph
    function createPatternGraph(node) {
      var graph = createAlternativesGraph(node.alternatives)
      svg.style.height = graph.box.height
      svg.style.width = graph.box.width < parseFloat(svg.style.minWidth) ? window.innerWidth * 0.8 : graph.box.width
      if (parseFloat(graph.box.width) < parseFloat(svg.style.minWidth)) {
        graph.g.style.transform = `translate(${(parseFloat(svg.style.minWidth) - parseFloat(graph.box.width)) / 2}px,${0}px)`
      }
      return graph
    }


    //用来判断要画的是什么节点类型 好调用对应的画图函数
    function createGraph(node) {

      if (node.type == 'Pattern') {
        return createPatternGraph(node)
      }
      if (node.type == 'Character') {
        return createCharacterGraph(node)
      }
      if (node.type == 'CharacterClass') {
        return createCharacterClassGraph(node)
      }
      if (node.type == 'Quantifier') {
        return createQuantifierGraph(node)
      }
      if (node.type == 'CaptrueGroup') {
        return createCaptrueGroupGraph(node)
      }

      if (node.type == 'Alternative') {
        return createAlternativeGraph(node)
      }
    }

    //用来创建svg元素
    // svg元素里 g标签是用来嵌套的
    //一创建元素就直接塞到页面里的svg里面去

    function svgElt(tagName, attrs) {
      var el = document.createElementNS('http://www.w3.org/2000/svg', tagName)
      svg = document.querySelector('#svg')


      for (var attr in attrs) {
        var val = attrs[attr]
        el.setAttribute(attr, val)
      }

      svg.append(el)
      return el

    }

    function add(init, widthNum) {
      return init + widthNum
    }
    function max(init, heightNum) {
      return Math.max(init, heightNum)
    }

    //画出单个元素  /a/  匹配到的a  传入的node是parseCharacter得到的对象
    //调用svgElt创建text放内容node(解析出来的正则对象)的内容(node.value)
    //svg里被包裹在g标签里的元素 他们要偏移都是基于g标签偏移的  利用x(水平偏移) y(垂直偏移)
    //得到创建出来的text的大小 用getBBox()
    //根据创建出来的text的大小调用svgElt创建存放text文本的背景盒子(rect)的大小(text压在rect上)
    //rect的大小是text宽高+2倍的padding
    //创建g标签用来当嵌套内容(text压在rect上)的盒子  因为g标签是唯一可以在svg里嵌套内容的标签
    //将rect和text按顺序添加进g标签  返回g标签(图片)和g标签的大小位置信息(图片的信息)组成的对象
    //padding定义在全局  因为所有生成正则图片的背景盒子都需要同一个padding

    function createCharacterGraph(node) {
      var text = svgElt('text', {
        y: 25,
        x: padding
      });
      text.textContent = node.value
      var textBox = text.getBBox()
      var rect = svgElt('rect', {
        width: textBox.width + 2 * padding,
        height: textBox.height + 2 * padding,
        fill: '#dae9e5',
        rx: padding / 4,
        ry: padding / 4
      })
      var g = svgElt('g')
      g.append(rect)
      g.append(text)

      return {
        g: g,
        box: g.getBBox()
      }
    }

    // 画法和单分支的画法差不多 甚至更简单  从上到下单列排列  不用画线连接
    // 画字符集的图像，由上到下成一列
    // 高度:(所以元素高度和+(元素数量+1)*padding)  宽度:(最宽的元素的宽度+2*padding)
    function createCharacterClassGraph(node) {
      if (!node.revert) {

        var subGraphs = node.elements.map(createGraph)
        var width = subGraphs.map(it => it.box.width).reduce(max, 0) + 2 * padding
        var height = subGraphs.map(it => it.box.height).reduce(add, 0) + (subGraphs.length + 1) * padding
        var g = svgElt('g')
        var rect = svgElt('rect', {   //创建rect
          width: width,
          height: height,
          fill: 'grey',
          rx: padding / 4,
          ry: padding / 4
        })
        g.append(rect)
        var offset = padding
        for (var graph of subGraphs) {
          graph.g.style.transform = `translate(${(width - graph.box.width) / 2}px,${offset}px)`
          g.append(graph.g)
          offset += padding + graph.box.height
        }
      } else {
        var subGraphs = node.elements.map(createGraph)
        var width = subGraphs.map(it => it.box.width).reduce(max, 0) + 2 * padding
        var height = subGraphs.map(it => it.box.height).reduce(add, 0) + (subGraphs.length + 1) * padding
        var g = svgElt('g')
        var rect = svgElt('rect', {   //创建rect
          width: width,
          height: height,
          fill: '#B34041',
          rx: padding / 4,
          ry: padding / 4
        })
        g.append(rect)
        var offset = padding
        for (var graph of subGraphs) {
          graph.g.style.transform = `translate(${(width - graph.box.width) / 2}px,${offset}px)`
          g.append(graph.g)
          offset += padding + graph.box.height
        }
      }


      return {   //画完之后返回一串字符的图片也包括g 和g 的大小
        g: g,
        box: g.getBBox()
      }
    }

    //创建单分支的图片分支  传入的node是ParseAlternative得到的对象 里面有个elements数组
    //横向拼接 所以宽度:(所有元素的宽度和+(数组元素个数+1)*padding)  高度:(最高的元素的高度+2*padding)
    function createAlternativeGraph(node) {
      var subGraphs = node.elements.map(createGraph)
      //得到单分支里每一部分的图，利用他们的宽高算出单分支图的rect(背景板)宽高
      var width = subGraphs.map(it => it.box.width).reduce(add, 0) + (subGraphs.length + 1) * padding
      var height = subGraphs.map(it => it.box.height).reduce(max, 0) + 2 * padding
      var g = svgElt('g') //创建g
      var rect = svgElt('rect', {  //利用刚刚得到的rect宽高创建出rect
        width: width,
        height: height,
        fill: 'none',
        rx: padding / 4,
        ry: padding / 4
      })
      var line = svgElt('path', {    //  *******创建连接线
        stroke: 'black',
        'stroke-width': '2',
        fill: 'none'
      })
      g.append(rect)// 将背景板添加进g
      g.append(line)//将连接线添加进g
      //计算偏移量以及计算画线距离数值部分///////////////////////////////////////////////////////////
      var offset = padding //用来累加计算的每个元素的左偏移值
      var d = ''           //拼接出的画线指令   M x y  L x y  或者 M x y H x  或者  M x y h -10
      for (var graph of subGraphs) {
        graph.g.style.transform = `translate(${offset}px,${(height - graph.box.height) / 2}px)`
        g.append(graph.g)
        d += `M ${offset} ${height / 2} h -${padding}` //每张子图片往左边画一条线
        line.setAttribute('d', d)   //更新一下line上的d属性的内容
        offset += padding + graph.box.width
      }
      d += `M ${offset} ${height / 2} h -${padding}`//还差最后一条右边的线
      line.setAttribute('d', d)

      return {
        g: g,
        box: g.getBBox()
      }
    }

    //创建多分支的图片分支  传入的node是ParseAlternatives得到的数组
    //纵向拼接 所以宽度:(最宽的单分支元素的高度+6*padding)  高度:(所有元素的宽度和+(数组元素个数+1)*padding)
    // 宽度:(最宽的单分支元素的宽度+6*padding)  是因为要留出足够多的空间去画连接线
    function createAlternativesGraph(node) {
      var subGraphs = node.map(createGraph)
      var width = subGraphs.map(it => it.box.width).reduce(max, 0) + 6 * padding
      var height = subGraphs.map(it => it.box.height).reduce(add, 0) + (subGraphs.length + 1) * padding
      var g = svgElt('g')
      var rect = svgElt('rect', {
        width: width,
        height: height,
        fill: '#98FB98'
      })
      var line = svgElt('path', {
        stroke: 'black',
        'stroke-width': '2',
        fill: 'none'
      })
      g.append(rect)
      g.append(line)
      var offset = padding
      var d = ``
      if (subGraphs.length % 2 == 0) {
        for (var i = 0; i < subGraphs.length; i++) {
          var graph = subGraphs[i]
          graph.g.style.transform = `translate(${(width - graph.box.width) / 2}px,${offset}px)`
          g.append(graph.g)
          if (offset + graph.box.height / 2 < height / 2) {
            if ((height / 2) - (offset + (graph.box.height / 2)) < 2 * padding) {
              if ((height / 2) - (offset + (graph.box.height / 2)) < padding) {
                var needRotate = (height / 2) - (offset + graph.box.height / 2)
                d += `
                 M 0 ${height / 2}
                 a ${padding} ${needRotate / 2} 0 0 0  ${padding} -${needRotate / 2}
                 a ${padding} ${needRotate / 2} 0 0 1  ${padding} -${needRotate / 2}
                 h ${(width - graph.box.width) / 2 - (padding + needRotate)}
                 M ${width} ${height / 2}
                 a ${padding} ${needRotate / 2} 0 0 1  -${padding} -${needRotate}
                 a ${padding} ${needRotate / 2} 0 0 0  -${padding} -${needRotate}
                 h -${(width - graph.box.width) / 2 - (padding + needRotate)}
                `
              }
              else {
                var needRotate = (height / 2) - (offset + graph.box.height / 2) - padding
                d += `
                 M 0 ${height / 2}
                 a ${padding} ${padding} 0 0 0  ${padding} -${padding}
                 a ${needRotate} ${needRotate} 0 0 1  ${needRotate} -${needRotate}
                 h ${(width - graph.box.width) / 2 - (padding + needRotate)}
                 M ${width} ${height / 2}
                 a ${padding} ${padding} 0 0 1  -${padding} -${padding}
                 a ${needRotate} ${needRotate} 0 0 0  -${needRotate} -${needRotate}
                 h -${(width - graph.box.width) / 2 - (padding + needRotate)}
                 `
              }
            }
            else {
              d += `
                 M 0 ${height / 2}
                 a ${padding} ${padding} 0 0 0  ${padding} -${padding}
                 v -${height / 2 - offset - graph.box.height / 2 - padding * 2}
                 a ${padding} ${padding} 0 0 1   ${padding} -${padding}
                 h ${(width - graph.box.width) / 2 - 2 * padding}
                 M ${width} ${height / 2}
                 a ${padding} ${padding} 0 0 1 ${-padding} -${padding}
                 v -${height / 2 - offset - graph.box.height / 2 - 2 * padding}
                 a ${padding} ${padding} 0 0 0  -${padding} -${padding}
                 h -${(width - graph.box.width) / 2 - 2 * padding}
                `
            }
          }
          else {
            if ((offset + graph.box.height / 2) - (height / 2) < 2 * padding) {
              if ((offset + graph.box.height / 2) - (height / 2) < padding) {
                var needRotate = (offset + graph.box.height / 2) - height / 2
                d += `
                   M 0 ${height / 2}
                   a ${padding} ${needRotate / 2} 0 0 1  ${padding} ${needRotate / 2}
                   a ${padding} ${needRotate / 2} 0 0 0  ${padding} ${needRotate / 2}
                   h ${(width - graph.box.width) / 2 - 2 * needRotate}
                   M ${width} ${height / 2}
                   a ${padding} ${needRotate / 2} 0 0 0  -${padding} ${needRotate / 2}
                   a ${padding} ${needRotate / 2} 0 0 1  -${padding} ${needRotate / 2}
                   h -${(width - graph.box.width) / 2 - 2 * needRotate}
                  `
              }
              else {
                var needRotate = ((offset + graph.box.height / 2) - (height / 2)) - padding
                d += `
                   M 0 ${height / 2}
                   a ${padding} ${padding} 0 0 1  ${padding} ${padding}
                   a ${needRotate} ${needRotate} 0 0 0  ${needRotate} ${needRotate}
                   h ${(width - graph.box.width) / 2 - (padding + needRotate)}
                   M ${width} ${height / 2}
                   a ${padding} ${padding} 0 0 0  -${padding} ${padding}
                   a ${needRotate} ${needRotate} 0 0 1  -${needRotate} ${needRotate}
                   h -${(width - graph.box.width) / 2 - (padding + needRotate)}
                   `
              }
            } else {
              d += `
                 M 0 ${height / 2}
                 a ${padding} ${padding} 0 0 1  ${padding} ${padding}
                 v ${offset - height / 2 + graph.box.height / 2 - 2 * padding}
                 a ${padding} ${padding} 0 0 0   ${padding} ${padding}
                 h ${(width - graph.box.width) / 2 - 2 * padding}
                 M ${width} ${height / 2}
                 a ${padding} ${padding} 0 0 0 ${-padding} ${padding}
                 v ${offset - height / 2 + graph.box.height / 2 - 2 * padding}
                 a ${padding} ${padding} 0 0 1   -${padding} ${padding}
                 h -${(width - graph.box.width) / 2 - 2 * padding}
                `
            }
          }
          line.setAttribute('d', d)
          offset += padding + graph.box.height
        }
      }
      else {
        for (var i = 0; i < subGraphs.length; i++) {
          var graph = subGraphs[i]
          graph.g.style.transform = `translate(${(width - graph.box.width) / 2}px,${offset}px)`
          g.append(graph.g)
          if (offset + graph.box.height / 2 < height / 2) {
            if ((height / 2) - (offset + (graph.box.height / 2)) < 2 * padding) {
              if ((height / 2) - (offset + (graph.box.height / 2)) < padding) {
                var needRotate = (height / 2) - (offset + graph.box.height / 2)
                d += `
                 M 0 ${height / 2}
                 a ${padding} ${needRotate / 2} 0 0 0  ${padding} -${needRotate / 2}
                 a ${padding} ${needRotate / 2} 0 0 1  ${padding} -${needRotate / 2}
                 h ${(width - graph.box.width) / 2 - 2 * needRotate}
                 M ${width} ${height / 2}
                 a ${padding} ${needRotate / 2} 0 0 1  -${padding} -${needRotate}
                 a ${padding} ${needRotate / 2} 0 0 0  -${padding} -${needRotate}
                 h -${(width - graph.box.width) / 2 - 2 * needRotate}
                `
              } else {
                var needRotate = (height / 2) - (offset + graph.box.height / 2) - padding
                d += `
                 M 0 ${height / 2}
                 a ${padding} ${padding} 0 0 0  ${padding} -${padding}
                 a ${padding} ${needRotate} 0 0 1  ${padding} -${needRotate}
                 h ${(width - (padding + needRotate) * 2) / 2}
                 M ${width} ${height / 2}
                 a ${padding} ${padding} 0 0 1  -${padding} -${padding}
                 a ${padding} ${needRotate} 0 0 0  -${padding} -${needRotate}
                 h -${(width - (padding + needRotate) * 2) / 2}
                 `
              }
            } else {
              d += `M 0 ${height / 2}
                    a ${padding} ${padding} 0 0 0  ${padding} -${padding}
                    v -${height / 2 - offset - graph.box.height / 2 - 2 * padding}
                    a ${padding} ${padding} 0 0 1   ${padding} -${padding}
                    h ${(width - graph.box.width) / 2 - 2 * padding}
                    M ${width} ${height / 2}
                    a ${padding} ${padding} 0 0 1 ${-padding} -${padding}
                    v -${height / 2 - offset - graph.box.height / 2 - 2 * padding}
                    a ${padding} ${padding} 0 0 0  -${padding} -${padding}
                    h -${(width - graph.box.width) / 2 - 2 * padding}
                   `
            }
          }
          else if (offset + graph.box.height / 2 == height / 2) {
            d += `M 0 ${height / 2}
                  h ${(width - graph.box.width) / 2}
                  M ${width} ${height / 2}
                  h -${(width - graph.box.width) / 2}
                `
          }
          else {
            d += `M 0 ${height / 2}
                  a ${padding} ${padding} 0 0 1  ${padding} ${padding}
                  v ${offset - height / 2 + graph.box.height / 2 - 2 * padding}
                  a ${padding} ${padding} 0 0 0   ${padding} ${padding}
                  h ${(width - graph.box.width) / 2 - 2 * padding}
                  M ${width} ${height / 2}
                  a ${padding} ${padding} 0 0 0 ${-padding} ${padding}
                  v ${offset - height / 2 + graph.box.height / 2 - 2 * padding}
                  a ${padding} ${padding} 0 0 1   -${padding} ${padding}
                  h -${(width - graph.box.width) / 2 - 2 * padding}
                `
          }
          line.setAttribute('d', d)
          offset += padding + graph.box.height
        }
      }

      return {
        g: g,
        box: g.getBBox()
      }


    }



    //因为括号里面也是个多分支所以只需要执行创建多分支图片的那个函数将多分支的图片先创建出来
    //然后再在多分支图片外套一层虚线框加背景图就可以表示这是个括号分组
    //但是括号分组的背景图和虚线框得放的大一点为了里面能放文字来表明这个是个什么类型得捕获分组
    function createCaptrueGroupGraph(node) {
      var graph = createAlternativesGraph(node.alternatives)
      var width = graph.box.width + 2 * padding
      var height = graph.box.height + 4 * padding
      var g = svgElt('g')
      var rect = svgElt('rect', {   //底图
        width: width,
        height: height,
        fill: '#98FB98'
      })
      g.append(rect)
      var border = svgElt('rect', {   //虚线边框
        width: graph.box.width,
        height: graph.box.height,
        rx: padding / 2,
        ry: padding / 2,
        stroke: 'grey',
        'stroke-dasharray': '4 5', //虚线画法
        fill: 'none'
      })
      var line = svgElt('path', {
        'stroke-width': '2',
        'stroke': 'black',
        fill: 'none'
      })
      g.append(line)
      d = `
           M 0 ${height / 2}  
           h ${2 * padding} 
           M ${width} ${height / 2}
           h -${2 * padding}
           `
      line.setAttribute('d', d)

      graph.g.style.transform = `translate(${padding}px, ${2 * padding}px)`
      g.append(graph.g)
      border.style.transform = `translate(${padding}px, ${2 * padding}px)`
      g.append(border)


      //括号分组得名称如果index>0表示肯定不是断言因为断言不计入分组计数里面
      if (node.index >= 0) {
        if (!node.name) {
          var text = createTextGraph('Group #' + node.index)
          g.append(text.g)
        } else {
          var text = createTextGraph(node.name)
          g.append(text.g)
        }
      }
      else if (node.assertion) {
        var str = createTextGraph(node.name)
        g.append(str.g)
      }
      return {
        g: g,
        box: g.getBBox()
      }
    }

    //最复杂得量词符得画法只出现一次和出现多次得线条画法
    function createQuantifierGraph(node) {
      var subGraph = createGraph(node.element)
      var height = 2 + subGraph.box.height + 2 * padding
      var width = node.min == 0 ? subGraph.box.width + 4 * padding : subGraph.box.width + 2 * padding
      var g = svgElt('g')
      var rect = svgElt('rect', {
        width: width,
        height: height,
        fill: '#98FB98'
      })
      g.append(rect)
      var line = svgElt('path', {
        'stroke-width': '2',
        'stroke': 'black',
        fill: 'none'
      })
      g.append(subGraph.g)
      subGraph.g.style.transform = `translate(${(width - subGraph.box.width) / 2}px,${padding + 1}px)`
      g.append(line)
      var d = ''
      d += `M 0 ${height / 2}
            h ${node.min == 0 ? 2 * padding : padding}
            M ${width} ${height / 2}
            h -${node.min == 0 ? 2 * padding : padding}
          `

      if (node.min == 0) {
        // 水平半轴长度 垂直半轴长度 旋转(对于椭圆有用) 优弧或者劣弧  逆时针0顺时针1  圆弧终点的坐标x 圆弧终点的坐标y
        d += `M ${0} ${height / 2}
             a${padding} ${padding} 0 0 0 ${padding} -${padding}      
             v -${height / 2 - 2 * padding}
             a${padding} ${padding} 0 0 1 ${padding} -${padding}
             h ${width - padding * 4}
             a ${padding} ${padding} 0 0 1 ${padding} ${padding}
             v${height / 2 - 2 * padding}
             a${padding} ${padding} 0 0 0 ${padding} ${padding}
             `
        line.setAttribute('d', d)

      }
      if (node.max > 1) {
        d += `
          M ${width - (width - subGraph.box.width) / 2} ${height / 2}
          a ${padding} ${padding} 0 0 1 ${padding} ${padding}
          v ${subGraph.box.height / 2 - padding}
          a ${padding} ${padding} 0 0 1 -${padding} ${padding} 
          h -${subGraph.box.width}
          a ${padding} ${padding} 0 0 1 -${padding} -${padding}
          v -${subGraph.box.height / 2 - padding}
          a ${padding} ${padding} 0 0 1 ${padding} -${padding}
        `
        line.setAttribute('d', d)
      }



      return {
        g: g,
        box: g.getBBox()
      }
    }


    function createTextGraph(text) {
      var txt = svgElt('text', {
        'dominant-baseline': 'text-before-edge',         //用于设置svg里text得baseline
        'class': 'colorTxt'
      })
      txt.textContent = text
      var g = svgElt('g')
      var rect = svgElt('rect', {
        width: txt.getBBox().width,
        height: txt.getBBox().height,
        fill: 'none'
      })
      g.append(rect)
      g.append(txt)
      return {
        g: g,
        box: g.getBBox()
      }
    }



  </script>

</body>

</html>
