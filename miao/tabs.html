<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>面向对象 Tab</title>

  <!-- <link rel="stylesheet" href="./styles/style.css"> -->
  <!-- <link rel="stylesheet" href="./styles/tab.css"> -->

  <style>
    @font-face {
      font-family: "iconfont";
      src: url('./iconfont/iconfont.eot?t=1553960438096');
      /* IE9 */
      src: url('./iconfont/iconfont.eot?t=1553960438096#iefix') format('embedded-opentype'),
        /* IE6-IE8 */
        url('data:application/x-font-woff2;charset=utf-8;base64,d09GMgABAAAAAAK4AAsAAAAABmwAAAJrAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHEIGVgCCcAp4fwE2AiQDCAsGAAQgBYRtBzAbpQXIrrApw71oi3CCOyzEy8RvE4yIN8TD036/zp03qCYRjaJZNBFFS/gREoRGipQKofjuNrb+9XbTqrmXcqWzfTRDqFqWkhAJzYToaE6LQ7Q30CirRqSKMnj58DdIdrNAdhoTQJa5VGfLrtiAy+lPoAcZdUC57UljTR4TMAo4oL0xiqwYG8YueIHPCdTqYajty/t+bUpmrwvEnUK42lQhLMssVy1UNhzN4kmF6vSQVvMY/T5+HEU1SUXBbti7uBBrx++cgqJULp0GhAgBna5AgSkgE0eN6R1NwTitNt0yAI5VG7wr/8AljmoX7K+zq+tBF1Q8k9JTPWp1AjnJDgCzmM3bU0V31dsvV3M2eC6fHjaGfX/qS7U5Gr58vj6uD0bgxudyrV/OtHHyP+NZnpO1txbktjdY+3FB61+7nxeOzq8niGYnRwT3v3aZxeXf6rrNxl5//49WlEtZUUL1Pj3Bv1EO7MuG2namrCkbvcnApLUJtWpRhv2tzlRLx43kQ7WO2/FW6c5QqDZEZnYKFeosoVK1NdSa5E/XaVM1Ra7BhAEQmk0kjV5QaLbIzG5U6HRRqTkK1DqJtivrjMT1zJaNnIsihAiyQE3JdbszcW0Xiadzdl4d8UO0HSUGNDNXzl2hifYSO5pPjrorgdjUAAavoa5TKDZVUXD3kuuOOzh70fShvUiN2owtNsRxIREIIiATUCYpGO2aqXy/CxEeHcfuaKrLDiGbQ5kcEMsNIK8M5qCmR3mn8RFHOpcECBtlAAwWIZ2OAqV5kQoJXHvShORYBzrDZKhhb3uT8QPlrA3bmsKZV6i89DiTV2o1AAAA') format('woff2'),
        url('./iconfont/iconfont.woff?t=1553960438096') format('woff'),
        url('./iconfont/iconfont.ttf?t=1553960438096') format('truetype'),
        /* chrome, firefox, opera, Safari, Android, iOS 4.2+ */
        url('./iconfont/iconfont.svg?t=1553960438096#iconfont') format('svg');
      /* iOS 4.1- */
    }

    .iconfont {
      font-family: "iconfont" !important;
      font-size: 16px;
      font-style: normal;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    .icon-guanbi:before {
      content: "\e676";
    }

    * {
      margin: 0;
      padding: 0;
    }

    ul li {
      list-style: none;
    }

    main {
      width: 960px;
      height: 500px;
      border-radius: 10px;
      margin: 50px auto;
    }

    main h4 {
      height: 100px;
      line-height: 100px;
      text-align: center;
    }

    .tabsbox {
      width: 900px;
      margin: 0 auto;
      height: 400px;
      border: 1px solid lightsalmon;
      position: relative;
    }

    nav ul {
      overflow: hidden;
    }

    nav ul li {
      float: left;
      width: 100px;
      height: 50px;
      line-height: 50px;
      text-align: center;
      border-right: 1px solid #ccc;
      position: relative;
    }

    nav ul li.liactive {
      border-bottom: 2px solid #fff;
      z-index: 9;
    }

    #tab input {
      width: 80%;
      height: 60%;
    }

    nav ul li span:last-child {
      position: absolute;
      user-select: none;
      font-size: 12px;
      top: -18px;
      right: 0;
      display: inline-block;
      height: 20px;
    }

    .tabadd {
      position: absolute;
      /* width: 100px; */
      top: 0;
      right: 0;
    }

    .tabadd span {
      display: block;
      width: 20px;
      height: 20px;
      line-height: 20px;
      text-align: center;
      border: 1px solid #ccc;
      float: right;
      margin: 10px;
      user-select: none;
    }

    .tabscon {
      width: 100%;
      height: 300px;
      position: absolute;
      padding: 30px;
      top: 50px;
      left: 0px;
      box-sizing: border-box;
      border-top: 1px solid #ccc;
    }

    .tabscon section,
    .tabscon section.conactive {
      display: none;
      width: 100%;
      height: 100%;
    }

    .tabscon section.conactive {
      display: block;
    }
  </style>

</head>

<body>

  <main>
    <h4>
      Js 面向对象 动态添加标签页
    </h4>
    <div class="tabsbox" id="tab">
      <!-- tab 标签 -->
      <nav class="fisrstnav">
        <ul>
          <li class="liactive"><span>测试1</span><span class="iconfont icon-guanbi"></span></li>
          <li><span>测试2</span><span class="iconfont icon-guanbi"></span></li>
          <li><span>测试3</span><span class="iconfont icon-guanbi"></span></li>
        </ul>
        <div class="tabadd">
          <span>+</span>
        </div>
      </nav>

      <!-- tab 内容 -->
      <div class="tabscon">
        <section class="conactive">测试1</section>
        <section>测试2</section>
        <section>测试3</section>
      </div>
    </div>
  </main>

  <script>

    var that;
    class Tab {
      constructor(id) {
        // 获取元素 
        that = this;
        this.main = document.querySelector(id); //拿到id为tab的大盒子

        this.add = this.main.querySelector('.tabadd');
        //li的父元素
        this.ul = this.main.querySelector('.fisrstnav ul');
        //section的父元素
        this.fsection = this.main.querySelector('.tabscon');

        this.init(); //把init写进constructor里那每次执行new tab() 的时候即页面加载的时候都会调用init函数
      }
      //初始化函数让tab大盒子里每个相关的元素在一打开页面的同时都绑定事件，所以这里的都是this指向大盒子里的元素
      init() {
        this.updateNode(); //动态获取到元素
        this.add.onclick = this.addTab.bind(this.add, this); //给加号添加上按钮事件
        // 给每一个小li都动态添加点击事件用for循环语句实现
        for (var i = 0; i < this.lis.length; i++) {
          this.lis[i].index = i;
          this.lis[i].onclick = this.taggleTab.bind(this.lis[i], this); //这里的函数不能加(),加了就直接调用了
          this.remove[i].onclick = this.removeTab.bind(this.remove[i], this);
          this.spans[i].ondblclick = this.editTab;
          this.sections[i].ondblclick = this.editTab;
        }
      }

      updateNode() { //这里用this也是指向的大盒子里的元素
        this.lis = this.main.querySelectorAll('li'); //动态拿到id为tab的大盒子里的所有li
        this.sections = this.main.querySelectorAll('section'); //动态拿到id为tab的大盒子里的所有section
        this.remove = this.main.querySelectorAll('.icon-guanbi'); //动态获取×号
        this.spans = this.main.querySelectorAll('.fisrstnav li span:first-child'); //获取所有的span

      }
      //清除所有样式功能
      clearClass() { //清空样式属性清空的也是大盒子里的元素样式属性所以用这里用this
        for (var i = 0; i < this.lis.length; i++) { //但是调用这个函数的始终是实例对象，constructor里的任何一个元素都是无法调用这个函数的
          this.lis[i].className = '';
          this.sections[i].className = '';
        }
      }
      // 1.切换功能
      taggleTab(that) {
        //在切换功能之前应该先调用一下清除所有样式功能先清除所有样式(排他思想)
        that.clearClass(); //这里用that是因为clearClass()里的两个this指向的调用者都应该是constructor里的元素
        this.className = 'liactive'; //这个函数的调用者是点击后的li所以这里用this
        that.sections[this.index].className = 'conactive'; //this.index是指当前选中的小li的索引号然后赋给sections当索引号
        //这里不用this是因为这里的this指向函数调用者的话是li，而li没有sections属性，他是在constructor里的，
        //所以得想个办法设置一个全局变量that从constructor里调用sections
      }

      // 2.添加功能
      addTab(that) {
        //创建li和section元素
        that.clearClass(); //在调用之前先清除掉所有的样式(排他)
        var random = Math.random();
        var li = '<li class="liactive"><span>新选项卡</span><span class="iconfont icon-guanbi"></span></li>';
        var section = '<section class="conactive">测试 ' + random + '</section>';
        //把这两个元素追加到对应的父元素里面去
        that.ul.insertAdjacentHTML('beforeend', li); //调用者是add这个+号按钮，但是加号按钮没有ul这个属性，他是在constructor里的所以用that
        that.fsection.insertAdjacentHTML('beforeend', section);
        that.init(); //每创建一次新的元素就重新获取一遍元素，然后在init()里利用排他思想给每个元素添加绑定事件

      }
      //3.删除功能
      removeTab(that, e) {
        e.stopPropagation(); //阻止冒泡，因为点击×号，他的父级li也有点击事件，li绑定的是切效果所以点击×号同时会冒泡触发li的切换效果
        //所以要阻止冒泡
        var index = this.parentNode.index;
        //remove方法可以直接删除指定对应的元素
        that.lis[index].remove();
        that.sections[index].remove();
        that.init(); //动态更新绑定元素事件，在init函数里有updateNode函数会 动态的获取最新的元素个数


        //附加功能实现选中(和删除无关)：
        // 当我们删除的不是选中状态的li 的时候,原来的选中状态li保持不变
        if (document.querySelector('.liactive')) return; //当if里的语句为真时return一下后面的代码就不会再被执行了
        // 当删除了选中状态的li的时候让他前一个里设置为选中状态
        index--;
        // 使用短路运算符：前真则执行后面的，前假则不再执行后面的，这里当前面的index--到0时则为假，就不再执行后面的点击事件了
        that.lis[index] && that.lis[index].click(); //click函数可以自动调用点击事件不用鼠标点击
      }
      // 4.修改功能
      editTab() {
        // 先一双击就获取原本的文字内容
        var str = this.innerHTML;
        // 再双击禁止选中文字
        window.getSelection ? window.getSelection().removeAllRanges() : document.selection.empty();
        this.innerHTML = '<input type="text">'; //this指向的是span，给它添加一个文本框
        var input = this.children[0]; //span的第一个孩子就是文本框，这里的操作是拿到文本框并且赋给 input
        input.value = str; //然后把原本双击获取到的文字内容赋给input的value
        input.select(); //这个操作可以让文本框的文字处于选定状态

        //①当鼠标离开时把文本框里的值给span
        input.onblur = function () {
          this.parentNode.innerHTML = this.value; //当鼠标离开时文本框的value值即this.value赋给span，
          //这里面的this是在function里面所以是指input，而span是inp的父级所以用this.parentNode表示span
        }

        //②当敲一下回车时也能把文本框里的值给span
        input.onkeyup = function (e) {
          if (e.keyCode === 13) {
            this.parentNode.innerHTML = this.value;
          }
        }
      }
    }
    new Tab('#tab'); //实例化类
  </script>
</body>

</html>
